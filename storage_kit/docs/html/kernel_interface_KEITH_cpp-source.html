<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>/mahony/code/beos/cvs_work/open-beos/storage_kit/source/lib/kernel_interface.KEITH.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.2.1 on Sun Feb 17 19:26:12 2002 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>/mahony/code/beos/cvs_work/open-beos/storage_kit/source/lib/kernel_interface.KEITH.cpp</h1><div class="fragment"><pre>00001 <font class="comment">//----------------------------------------------------------------------</font>
00002 <font class="comment">// kernel_interface.POSIX.cpp</font>
00003 <font class="comment">// Initial implementation of our kernel interface with calls to </font>
00004 <font class="comment">// POSIX api. This will later be replaced with a version that</font>
00005 <font class="comment">// makes syscalls into the actual kernel</font>
00006 <font class="comment">//----------------------------------------------------------------------</font>
00007 
00008 <font class="preprocessor">#include "kernel_interface.h"</font>
00009 
00010 <font class="preprocessor">#include &lt;fcntl.h&gt;</font>
00011 <font class="preprocessor">#include &lt;dirent.h&gt;</font>
00012 <font class="preprocessor">#include &lt;unistd.h&gt;</font>
00013 
00014 <font class="keyword">typedef</font> <font class="keyword">struct </font>{
00015     stream_type st;
00016     DIR* dir;
00017     <font class="keywordtype">int</font> file;
00018 } fd_struct;
00019 
00020 <font class="keyword">const</font> <font class="keywordtype">int</font> MAX_DESC = 256;
00021 <font class="keyword">static</font> fd_struct our_fds[MAX_DESC];
00022 <font class="keyword">static</font> <font class="keywordtype">int</font> highest_fd = -1;
00023 
00024 
00025 <font class="comment">// The following two functions allocate and free file descriptors</font>
00026 <font class="comment">// to make this emulation layer thread safe, they should have</font>
00027 <font class="comment">// some kind of semaphore around them.</font>
00028 <font class="keyword">static</font> <font class="keywordtype">int</font> storage_kit::alloc_fd()<font class="keyword">
</font>00029 <font class="keyword"></font>{
00030     <font class="comment">// Allocate a file descriptor</font>
00031     <font class="keywordflow">for</font> (<font class="keywordtype">int</font> i = 0; i &lt; highest_fd; i++) {
00032         <font class="keywordflow">if</font> (our_fds[i].st == STREAM_TYPE_ANY) {
00033             <font class="comment">// Free one - use it</font>
00034             <font class="keywordflow">return</font> i;
00035         }
00036     }
00037 
00038     <font class="comment">// Fell through = use next in list</font>
00039     <font class="keywordflow">if</font> (highest_fd &lt; MAX_DESC) {
00040         <font class="keywordflow">return</font> ++highest_fd;
00041     } <font class="keywordflow">else</font> {
00042         <font class="keywordflow">return</font> ERR_VFS_FD_TABLE_FULL; <font class="comment">// or throw</font>
00043     }
00044 }
00045 
00046 
00047 <font class="keyword">static</font> <font class="keywordtype">void</font> storage_kit::free_fd(<font class="keywordtype">int</font> fd)<font class="keyword">
</font>00048 <font class="keyword"></font>{
00049     our_fds[fd].st = STREAM_TYPE_ANY;
00050 }
00051 
00052 <font class="comment">// End of thread unsafe code</font>
00053 <font class="keywordtype">int</font> storage_kit::open(<font class="keyword">const</font> <font class="keywordtype">char</font> *path, stream_type st, <font class="keywordtype">int</font> omode)<font class="keyword">
</font>00054 <font class="keyword"></font>{
00055     <font class="comment">// Open a file or directory</font>
00056     <font class="keywordtype">int</font> fd = storage_kit::alloc_fd();
00057     <font class="keywordflow">if</font> (fd &gt;= 0) {
00058         <font class="comment">// Which type of stream are we opening?</font>
00059         <font class="keywordflow">switch</font> (st) {
00060             <font class="keywordflow">case</font> STREAM_TYPE_ANY:
00061             <font class="keywordflow">case</font> STREAM_TYPE_DEVICE:
00062             <font class="keywordflow">default</font>:
00063             storage_kit::free_fd(fd);
00064             fd = ERR_VFS_WRONG_STREAM_TYPE;
00065             <font class="keywordflow">break</font>;
00066 
00067             <font class="keywordflow">case</font> STREAM_TYPE_FILE:
00068             our_fds[fd].st = st;
00069             our_fds[fd].file = ::open(path, omode, 0777);
00070             <font class="keywordflow">if</font> (our_fds[fd].file &lt; 0) {
00071                 storage_kit::free_fd(fd);
00072                 fd = ERR_VFS_PATH_NOT_FOUND; <font class="comment">// Dodgy code</font>
00073             }
00074             <font class="keywordflow">break</font>;
00075             <font class="keywordflow">case</font> STREAM_TYPE_DIR:
00076             our_fds[fd].st = st;
00077             our_fds[fd].dir = ::opendir(path);
00078             <font class="keywordflow">if</font> (our_fds[fd].dir == NULL) {
00079                 storage_kit::free_fd(fd);
00080                 fd = ERR_VFS_PATH_NOT_FOUND; <font class="comment">// Only error in posix docs</font>
00081             }
00082             <font class="keywordflow">break</font>;
00083         }
00084     }
00085     <font class="keywordflow">return</font> fd;
00086 }
00087 
00088 <font class="keywordtype">int</font> storage_kit::close(<font class="keywordtype">int</font> fd)<font class="keyword">
</font>00089 <font class="keyword"></font>{
00090     <font class="comment">// Which type of stream are we opening?</font>
00091     <font class="keywordtype">int</font> err = NO_ERROR;
00092     <font class="keywordflow">switch</font> (our_fds[fd].st) {
00093         <font class="keywordflow">case</font> STREAM_TYPE_ANY:
00094         <font class="keywordflow">case</font> STREAM_TYPE_DEVICE:
00095         <font class="keywordflow">default</font>:
00096             <font class="keywordflow">return</font> ERR_VFS_INVALID_FS; <font class="comment">// fd table corruption!</font>
00097 
00098         <font class="keywordflow">case</font> STREAM_TYPE_FILE:
00099             <font class="keywordflow">if</font>(::close(our_fds[fd].file) &lt; 0) {
00100                 err = ERR_VFS_INVALID_FS;
00101             }
00102             <font class="keywordflow">break</font>;
00103         <font class="keywordflow">case</font> STREAM_TYPE_DIR:
00104             ::closedir(our_fds[fd].dir);
00105         <font class="keywordflow">break</font>;
00106     }
00107     <font class="keywordflow">return</font> fd;
00108 }
00109 
00110 size_t storage_kit::read(<font class="keywordtype">int</font> fd, <font class="keywordtype">void</font> *buf, off_t pos, ssize_t len)<font class="keyword">
</font>00111 <font class="keyword"></font>{
00112     <font class="comment">// Get some data frm a file (or directory)</font>
00113     <font class="keywordtype">int</font> err = NO_ERROR;
00114     size_t data_read;
00115 
00116     <font class="keywordflow">switch</font> (our_fds[fd].st) {
00117         <font class="keywordflow">case</font> STREAM_TYPE_ANY:
00118         <font class="keywordflow">case</font> STREAM_TYPE_DEVICE:
00119         <font class="keywordflow">default</font>:
00120             <font class="keywordflow">return</font> ERR_VFS_INVALID_FS; <font class="comment">// fd table corruption!</font>
00121 
00122         <font class="keywordflow">case</font> STREAM_TYPE_FILE:
00123             <font class="keywordflow">if</font>(pos &lt; 0) {
00124             <font class="comment">// Use current position</font>
00125             data_read = ::read(our_fds[fd].file, buf, len);
00126             } <font class="keywordflow">else</font> {
00127             <font class="comment">// Positional read</font>
00128             ::lseek(our_fds[fd].file, pos, SEEK_CUR);
00129             data_read = ::read(our_fds[fd].file, buf, len);
00130             }
00131             <font class="keywordflow">break</font>;
00132         <font class="keywordflow">case</font> STREAM_TYPE_DIR:
00133             <font class="keyword">struct </font>dirent *dp = ::readdir(our_fds[fd].dir);
00134             if (dp == NULL) {
00135                 data_read = 0;
00136             } <font class="keywordflow">else</font> {
00137                 <font class="keywordflow">if</font> (strlen(dp-&gt;d_name) &gt; len) {
00138                     <font class="comment">// Not enough room</font>
00139                     *((<font class="keywordtype">char</font>*)buf) = <font class="charliteral">'\0'</font>;
00140                     data_read = ERR_VFS_INSUFFICIENT_BUF;
00141                 } <font class="keywordflow">else</font> {
00142                     strcpy((<font class="keywordtype">char</font>*)buf, dp-&gt;d_name);
00143                     data_read = strlen(dp-&gt;d_name);
00144                 }
00145             }
00146             <font class="keywordflow">break</font>;
00147     }
00148     <font class="keywordflow">return</font> data_read;
00149 }
00150 
00151 
00152 
</div></pre><hr><address><small>Generated at Sun Feb 17 19:26:12 2002 for OpenBeOS Storage Kit by
<a href="http://www.stack.nl/~dimitri/doxygen/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.1 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2000</small></address>
</body>
</html>
