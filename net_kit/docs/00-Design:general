Just some general thoughts that have occurred to me as I've started
looking at stuff related to designing a network stack...

These are in no particular order.

General Jottings
----------------

- zero-copy is a laudible aim, but in reality single copy is probably
  as good as we're going to get to.  Basically this means that we copy data
  into the stack at some point.
- we should use a version of the mbuff's that the BSD stack uses with changes
  so we use them more efficiently for our stack.
- probably need an rx and tx queue for frames.
- we should reallt be dealing with frames as soon as we can in the stack,
  though we don't want to fragment earlier than we need to - what a quandry!
- it should be possible to stack/reorder modules as needed. This would be cool
  if we could deal with input from other sources, e.g. data from a USB port
  to be fed into a ppp stack, onto an atm/ethernet frame module and upwards.


Userland vs Kernel Land
-----------------------

- stack lives in kernel land. apps live in userland.
- do we need to copy data from top level of stack into userland?
  Probably to keep memory in correct "area".

Initial Protocols
-----------------

- ethernet encapsulation
- 802.x encapsulation
- ipv4
- udp
- arp
- icmpv4

Extra's
-------

- ipv6
- icmpv6
- ipv6 discovery (arp for v6)
- atm encapsulation module?
- ppp module
- usb interface (net stack to usb??)

Stack Map
=========

So, how does this all fit together???

[david: My ascii art is terrible, so hope this works out :)]

			=================
			= User apps	=   		USERLAND
			=================
			|		|
		----------------------------------
			|		|
		=========   =========	=========
		= UDP   =   = ICMP* =	= TCP	=	KERNEL
		=========   =========	=========
			 \      |      /
			  \     |     /
			   ===========
			  /           \
			 /             \
		=========   =========	=========
		= IPv4  =   =  ARP  =	= IPv6  =
		=========   =========	=========
                         \      |      /
		          \     |     /
                           ===========
                          /           \
                         /             \
                =========               =========
                = Eth   =               = 802.x =
                =========               =========
                         \             /
                          \           /
                           ===========
				|
			   ===========
			   = NIC IF  =
			   ===========

* ICMP is used as a placeholder for both ICMPv4 and ICMPv6, which are very
  different from each other in scope and usage.

This just starts to scratch the surface, but I hope gives more of an idea
of what's been bouncing around in my head. :)

Frames going up/down the stack should really be able to follow any path
desired, something that isn't possible with the current newos stack. We 
almost need a structure that mimcs the above, such as

	switch (frame->encaps_type)
		case ethernet:
			go ethernet;
		case 802.x:
			go 802.x;
/* assume that in the encaps layer we set the layer2_proto unless we
 * process the data ourselves (arp)
 */
	switch (frame->layer2_proto)
		case ipv4;
		case arp;
		case ipv6;
/* assume that these either process totally or reply with
 * layer3_proto set */
	switch (frame->layer3_proto)
etc, etc

One thing that this could allow is for each module visited to attach a 
pointer such that we can then call

	frame->layer2->output(data)

For this I'd imagine a structure whereby we have this...

	struct if_frame {
		addr buffer;	/* points to start of buffer */
		size_t buflen;	/* how big is the buffer? */
		addr nxt;	/* points to where we should start reading */
		addr layer1;	/* points to start of layer1 header */
		addr layer2;
		addr layer3;
		ifnet *if;	/* interface we came in on */

		struct io_funcs *layer1; /* i/o functions for layer 1 */
...
		uint32 history;	/* bitflags showing which modules have
				 * processed packet... */
		char data[???]; /* data buffer */
	}

This breaks from what newos currently uses (cbufs) in that we don't dispose of
the headers we've used, but rather hang onto them so subsequent layers can refer
back. This should reduce the amount of copying we need to do whilst traversing 
the stack. It does raise questions about where the fragmentation/reconstruction
takes place and how we deal with larger packets. I'd imagine that we'd have a
list of these structures with a basic (smallish) data buffer (say 256 bytes 
for the whole structure, and if the frame was beyond what could be accomodated
we simply attach a buffer large enough and use that for the data. In this way
I think we can avoid having 2 memcpy's per large packet?

This would mean that we abstract out a lot of the module specifics. It should
also allow great debugging opportunities :)


